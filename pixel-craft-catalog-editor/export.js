// Export Module - Generates native Verse code from catalog data
// Exports directly to Verse structs with bracket syntax

// Main export function - exports all catalogs
function exportAllCatalogs() {
    try {
        // Validate before export
        const validationErrors = validateAllCatalogs();
        if (validationErrors.length > 0) {
            const proceed = confirm(
                `⚠️ Encontrados ${validationErrors.length} erros de validação!\n\n` +
                `Primeiros 3 erros:\n${validationErrors.slice(0, 3).join('\n')}\n\n` +
                `Exportar mesmo assim? (NÃO RECOMENDADO)`
            );
            if (!proceed) return;
        }

        // Generate and download each catalog
        const itemsVerse = generateItemsCatalog();
        Utils.downloadText(itemsVerse, CONSTANTS.EXPORT_FILES.items);

        const breakablesVerse = generateBreakablesCatalog();  // NOVO
        Utils.downloadText(breakablesVerse, CONSTANTS.EXPORT_FILES.breakables);  // NOVO

        const recipesVerse = generateRecipesCatalog();
        Utils.downloadText(recipesVerse, CONSTANTS.EXPORT_FILES.recipes);

        const workstationsVerse = generateWorkstationsCatalog();
        Utils.downloadText(workstationsVerse, CONSTANTS.EXPORT_FILES.workstations);

        const makeshiftVerse = generateMakeshiftConfig();
        Utils.downloadText(makeshiftVerse, CONSTANTS.EXPORT_FILES.makeshift);

        Utils.showAlert('success', `✅ 5 arquivos Verse exportados com sucesso!`);  // MUDANÇA: 4 → 5

    } catch (error) {
        Utils.showAlert('error', `Exportação falhou: ${error.message}`);
        throw error;
    }
}

// Validate all catalogs before export
function validateAllCatalogs() {
    const errors = [];

    // Validate items
    state.items.forEach((item, i) => {
        if (!item.id) errors.push(`Item ${i}: Missing ID`);
        if (!item.name) errors.push(`Item ${i}: Missing name`);
        if (!item.type) errors.push(`Item ${i}: Missing type`);
    });

    // Validate breakables  // NOVO
    state.breakables.forEach((br, i) => {
        if (!br.id) errors.push(`Breakable ${i}: Missing ID`);
        if (br.hardness === undefined || br.hardness === null) errors.push(`Breakable ${i}: Missing hardness`);
        if (br.drop_table) {
            br.drop_table.forEach((drop, j) => {
                if (!drop.item_id) errors.push(`Breakable ${i}, Drop ${j}: Missing item_id`);
                if (!State.getItemById(drop.item_id)) {
                    errors.push(`Breakable ${i}, Drop ${j}: Item "${drop.item_id}" not found`);
                }
            });
        }
    });

    // Validate recipes
    state.recipes.forEach((recipe, i) => {
        if (!recipe.id) errors.push(`Recipe ${i}: Missing ID`);
        if (!recipe.output_item_id) errors.push(`Recipe ${i}: Missing output_item_id`);
        if (!State.getItemById(recipe.output_item_id)) {
            errors.push(`Recipe ${i}: Output item "${recipe.output_item_id}" not found`);
        }
    });

    // Validate workstations
    state.workstations.forEach((ws, i) => {
        if (!ws.workstation_def_id) errors.push(`Workstation ${i}: Missing workstation_def_id`);
        const item = State.getItemById(ws.workstation_def_id);
        if (!item) {
            errors.push(`Workstation ${i}: Item "${ws.workstation_def_id}" not found`);
        } else if (item.type !== 'Placeable') {
            errors.push(`Workstation ${i}: Item "${ws.workstation_def_id}" is not Placeable`);
        }
    });

    return errors;
}

// Helper function to format float values correctly for Verse
function formatFloat(value) {
    const num = parseFloat(value) || 0;
    
    // If the number is already a float (has decimal places), return as is
    if (num % 1 !== 0) {
        return num.toString();
    }
    
    // If it's an integer, add .0
    return num.toFixed(1);
}

// Generate Items Catalog (ItemsCatalog.verse)
function generateItemsCatalog() {
    const timestamp = new Date().toISOString();
    const username = state.metadata.username || 'unknown';

    let verse = `# ItemsCatalog.verse
# Generated by Pixel Craft Catalog Editor
# Date: ${timestamp}
# User: ${username}
# Items: ${state.items.length}

using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { ItemSystem.ItemData }
using { ItemSystem.ItemTypes }

ItemsCatalog<public> := module{
    AllItems<public> : []item_def = array{
`;

    state.items.forEach((item, index) => {
        const isLast = index === state.items.length - 1;
        verse += generateItemDef(item, isLast);
    });

    verse += `    }
}
`;

    return verse;
}

// Generate individual item definition in Verse
function generateItemDef(item, isLast) {
    const type = item.type || 'Resource';
    let verse = '';
    const indent = '        ';

    // Determine which class to use
    if (type === 'Equipment') {
        verse += `${indent}equipment_def{\n`;
        verse += `${indent}    Id := "${escapeString(item.id)}"\n`;
        verse += `${indent}    Name := "${escapeString(item.name)}"\n`;
        verse += `${indent}    Type := item_type.Equipment\n`;
        verse += `${indent}    Description := "${escapeString(item.description || '')}"\n`;
        verse += `${indent}    MaxStack := 1\n`;
        verse += `${indent}    Metadata := ${generateMetadata(item.metadata || {})}\n`;
        verse += `${indent}    EquipSlot := equip_slot.${item.equip_slot || 'Weapon'}\n`;
        verse += `${indent}    IsUnbreakable := ${item.is_unbreakable === 'true' || item.is_unbreakable === true ? 'true' : 'false'}\n`;
        verse += `${indent}    RequiredLevelToCraft := ${item.required_level_to_craft || 0}\n`;
        verse += `${indent}    ExpAfterCraft := ${item.exp_after_craft || 0}\n`;
        verse += `${indent}    BaseStat := ${formatFloat(item.base_stat || 0)}\n`;
        verse += `${indent}}`;

    } else if (type === 'Resource') {
        verse += `${indent}resource_def{\n`;
        verse += `${indent}    Id := "${escapeString(item.id)}"\n`;
        verse += `${indent}    Name := "${escapeString(item.name)}"\n`;
        verse += `${indent}    Type := item_type.Resource\n`;
        verse += `${indent}    Description := "${escapeString(item.description || '')}"\n`;
        verse += `${indent}    MaxStack := ${item.max_stack || CONSTANTS.MAX_STACK}\n`;
        verse += `${indent}    Metadata := ${generateMetadata(item.metadata || {})}\n`;
        verse += `${indent}}`;

    } else if (type === 'Consumable') {
        verse += `${indent}consumable_def{\n`;
        verse += `${indent}    Id := "${escapeString(item.id)}"\n`;
        verse += `${indent}    Name := "${escapeString(item.name)}"\n`;
        verse += `${indent}    Type := item_type.Consumable\n`;
        verse += `${indent}    Description := "${escapeString(item.description || '')}"\n`;
        verse += `${indent}    MaxStack := ${item.max_stack || CONSTANTS.MAX_STACK}\n`;
        verse += `${indent}    Metadata := ${generateMetadata(item.metadata || {})}\n`;
        verse += `${indent}    EffectType := effect_type.${item.effect_type || 'InstantHeal'}\n`;
        verse += `${indent}    Amount := ${formatFloat(item.effect_amount || 0)}\n`;
        verse += `${indent}    Duration := ${formatFloat(item.effect_duration || 0)}\n`;
        verse += `${indent}}`;

    } else if (type === 'Placeable') {
        verse += `${indent}placeable_def{\n`;
        verse += `${indent}    Id := "${escapeString(item.id)}"\n`;
        verse += `${indent}    Name := "${escapeString(item.name)}"\n`;
        verse += `${indent}    Type := item_type.Placeable\n`;
        verse += `${indent}    Description := "${escapeString(item.description || '')}"\n`;
        verse += `${indent}    MaxStack := 1\n`;
        verse += `${indent}    Metadata := ${generateMetadata(item.metadata || {})}\n`;
        verse += `${indent}    PlaceableBehaviorType := placeable_behavior_type.${item.behavior_type || 'Decoration'}\n`;
        verse += `${indent}}`;
    }

    verse += isLast ? '\n' : ',\n';
    return verse;
}

// Generate metadata map in Verse format
function generateMetadata(metadata) {
    const entries = Object.entries(metadata);
    
    if (entries.length === 0) {
        return `map{}`;
    }

    let verse = 'map{\n';
    entries.forEach(([key, value], index) => {
        const isLast = index === entries.length - 1;
        verse += `                "${escapeString(key)}" => "${escapeString(value)}"`;
        verse += isLast ? '\n' : ',\n';
    });
    verse += '            }';
    
    return verse;
}

// Generate Recipes Catalog (RecipesCatalog.verse)
function generateRecipesCatalog() {
    const timestamp = new Date().toISOString();
    const username = state.metadata.username || 'unknown';

    let verse = `# RecipesCatalog.verse
# Generated by Pixel Craft Catalog Editor
# Date: ${timestamp}
# User: ${username}
# Recipes: ${state.recipes.length}

using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { ItemSystem.RecipeData }

RecipesCatalog<public> := module{
    AllRecipes<public> : []recipe_def = array{
`;

    state.recipes.forEach((recipe, index) => {
        const isLast = index === state.recipes.length - 1;
        verse += generateRecipeDef(recipe, isLast);
    });

    verse += `    }
}
`;

    return verse;
}

// Generate individual recipe definition in Verse
function generateRecipeDef(recipe, isLast) {
    const indent = '        ';
    let verse = `${indent}recipe_def{\n`;
    verse += `${indent}    Id := "${escapeString(recipe.id)}"\n`;
    verse += `${indent}    OutputItemDefId := "${escapeString(recipe.output_item_id)}"\n`;
    verse += `${indent}    OutputAmount := ${recipe.output_amount || 1}\n`;
    verse += `${indent}    MaterialRequirements := `;

    const materials = recipe.materials || [];
    if (materials.length === 0) {
        verse += `array{}\n`;
    } else {
        verse += `array{\n`;
        materials.forEach((mat, matIndex) => {
            const isLastMat = matIndex === materials.length - 1;
            verse += `${indent}        material_requirement{\n`;
            verse += `${indent}            MaterialDefId := "${escapeString(mat.item_id)}"\n`;
            verse += `${indent}            Amount := ${mat.amount || 1}\n`;
            verse += `${indent}        }`;
            verse += isLastMat ? '\n' : ',\n';
        });
        verse += `${indent}    }\n`;
    }

    verse += `${indent}    SkilledDifficulty := ${recipe.skilled_difficulty || 0}\n`;
    verse += `${indent}    ShouldStartVisible := ${recipe.should_start_visible ? 'true' : 'false'}\n`;
    verse += `${indent}}`;
    verse += isLast ? '\n' : ',\n';

    return verse;
}

// Generate Workstations Catalog (WorkstationsCatalog.verse)
function generateWorkstationsCatalog() {
    const timestamp = new Date().toISOString();
    const username = state.metadata.username || 'unknown';

    let verse = `# WorkstationsCatalog.verse
# Generated by Pixel Craft Catalog Editor
# Date: ${timestamp}
# User: ${username}
# Workstations: ${state.workstations.length}

using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { ItemSystem.RecipeData }
using { ItemSystem.ItemTypes }

WorkstationsCatalog<public> := module{
    AllWorkstations<public> : []workstation_content_def = array{
`;

    state.workstations.forEach((ws, index) => {
        const isLast = index === state.workstations.length - 1;
        verse += generateWorkstationDef(ws, isLast);
    });

    verse += `    }
}
`;

    return verse;
}

// Generate individual workstation definition in Verse
function generateWorkstationDef(ws, isLast) {
    const indent = '        ';
    let verse = `${indent}workstation_content_def{\n`;
    verse += `${indent}    WorkstationDefId := "${escapeString(ws.workstation_def_id)}"\n`;
    verse += `${indent}    AvailableRecipesIDs := `;

    const recipes = ws.available_recipes || [];
    if (recipes.length === 0) {
        verse += `array{}\n`;
    } else {
        verse += `array{\n`;
        recipes.forEach((recipeId, idx) => {
            const isLastRecipe = idx === recipes.length - 1;
            verse += `${indent}        "${escapeString(recipeId)}"`;
            verse += isLastRecipe ? '\n' : ',\n';
        });
        verse += `${indent}    }\n`;
    }

    verse += `${indent}    UpgradeDefinitions := `;

    const upgrades = ws.upgrades || [];
    if (upgrades.length === 0) {
        verse += `array{}\n`;
    } else {
        verse += `array{\n`;
        upgrades.forEach((upgrade, upIndex) => {
            const isLastUpgrade = upIndex === upgrades.length - 1;
            verse += `${indent}        workstation_upgrade_def{\n`;
            verse += `${indent}            Id := "${escapeString(upgrade.id)}"\n`;
            verse += `${indent}            TargetLevel := ${upgrade.target_level || (upIndex + 1)}\n`;
            verse += `${indent}            UpgradeRequirements := `;

            const upMaterials = upgrade.upgrade_requirements || [];
            if (upMaterials.length === 0) {
                verse += `array{}\n`;
            } else {
                verse += `array{\n`;
                upMaterials.forEach((mat, matIdx) => {
                    const isLastMat = matIdx === upMaterials.length - 1;
                    verse += `${indent}                material_requirement{\n`;
                    verse += `${indent}                    MaterialDefId := "${escapeString(mat.item_id)}"\n`;
                    verse += `${indent}                    Amount := ${mat.amount || 1}\n`;
                    verse += `${indent}                }`;
                    verse += isLastMat ? '\n' : ',\n';
                });
                verse += `${indent}            }\n`;
            }

            verse += `${indent}            EffectDescription := "${escapeString(upgrade.effect_description || '')}"\n`;
            verse += `${indent}            BoostTypes := `;

            const boosts = upgrade.boost_types || [];
            if (boosts.length === 0) {
                verse += `array{}\n`;
            } else {
                verse += `array{\n`;
                boosts.forEach((boost, boostIdx) => {
                    const isLastBoost = boostIdx === boosts.length - 1;
                    verse += `${indent}                workstation_boost_type.${boost}`;
                    verse += isLastBoost ? '\n' : ',\n';
                });
                verse += `${indent}            }\n`;
            }

            // NOVO: Adicionar AvailableRecipesIDs
            verse += `${indent}            AvailableRecipesIDs := `;
            const upgradeRecipes = upgrade.available_recipes_ids || [];
            if (upgradeRecipes.length === 0) {
                verse += `array{}\n`;
            } else {
                verse += `array{\n`;
                upgradeRecipes.forEach((recipeId, recIdx) => {
                    const isLastRec = recIdx === upgradeRecipes.length - 1;
                    verse += `${indent}                "${escapeString(recipeId)}"`;
                    verse += isLastRec ? '\n' : ',\n';
                });
                verse += `${indent}            }\n`;
            }

            verse += `${indent}        }`;
            verse += isLastUpgrade ? '\n' : ',\n';
        });
        verse += `${indent}    }\n`;
    }

    verse += `${indent}}`;
    verse += isLast ? '\n' : ',\n';
    return verse;
}

// Generate Makeshift Config (MakeshiftConfig.verse)
function generateMakeshiftConfig() {
    const timestamp = new Date().toISOString();
    const username = state.metadata.username || 'unknown';

    let verse = `# MakeshiftConfig.verse
# Generated by Pixel Craft Catalog Editor
# Date: ${timestamp}
# User: ${username}
# Makeshift Recipes: ${state.makeshift.available_recipes.length}

using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { ItemSystem.RecipeInterfaces }

MakeshiftConfig<public> := module{
    MakeshiftRecipes<public> : []string = `;

    const recipes = state.makeshift.available_recipes || [];
    if (recipes.length === 0) {
        verse += `array{}\n`;
    } else {
        verse += `array{\n`;
        recipes.forEach((recipeId, index) => {
            const isLast = index === recipes.length - 1;
            verse += `        "${escapeString(recipeId)}"`;
            verse += isLast ? '\n' : ',\n';
        });
        verse += `    }\n`;
    }

    verse += `}
`;

    return verse;
}

// Generate Breakables Catalog (BreakablesCatalog.verse)
function generateBreakablesCatalog() {
    const timestamp = new Date().toISOString();
    const username = state.metadata.username || 'unknown';

    let verse = `# BreakablesCatalog.verse
# Generated by Pixel Craft Catalog Editor
# Date: ${timestamp}
# User: ${username}
# Breakables: ${state.breakables.length}

using { /Verse.org/Simulation }
using { /UnrealEngine.com/Temporary/Diagnostics }
using { ItemSystem.BreakableData }
using { ItemSystem.DropsConfig }


BreakableResourcesCatalog<public> := module{
    AllBreakables<public> : []breakable_resource_def = array{
`;

    state.breakables.forEach((br, index) => {
        const isLast = index === state.breakables.length - 1;
        verse += generateBreakableDef(br, isLast);
    });

    verse += `    }
}
`;

    return verse;
}

// Generate individual breakable definition in Verse
function generateBreakableDef(br, isLast) {
    const indent = '        ';
    let verse = `${indent}breakable_resource_def{\n`;
    verse += `${indent}    Id := "${escapeString(br.id)}"\n`;
    verse += `${indent}    Hardness := ${formatFloat(br.hardness || 0)}\n`;
    verse += `${indent}    RegenSeconds := ${formatFloat(br.regen_seconds || 0)}\n`;
    verse += `${indent}    DropTable := `;

    const drops = br.drop_table || [];
    if (drops.length === 0) {
        verse += `array{}\n`;
    } else {
        verse += `array{\n`;
        drops.forEach((drop, dropIndex) => {
            const isLastDrop = dropIndex === drops.length - 1;
            verse += `${indent}        drop_entry{\n`;
            verse += `${indent}            ItemID := "${escapeString(drop.item_id)}"\n`;
            verse += `${indent}            Weight := ${drop.weight || 1}\n`;
            verse += `${indent}            MinAmount := ${drop.min_amount || 1}\n`;
            verse += `${indent}            MaxAmount := ${drop.max_amount || 1}\n`;
            verse += `${indent}        }`;
            verse += isLastDrop ? '\n' : ',\n';
        });
        verse += `${indent}    }\n`;
    }

    verse += `${indent}}`;
    verse += isLast ? '\n' : ',\n';

    return verse;
}

// Escape special characters in strings for Verse
function escapeString(str) {
    if (typeof str !== 'string') return '';
    return str
        .replace(/\\/g, '\\\\')   // Backslash
        .replace(/"/g, '\\"')     // Double quote
        .replace(/\n/g, '\\n')    // Newline
        .replace(/\r/g, '\\r')    // Carriage return
        .replace(/\t/g, '\\t');   // Tab
}

// Export to window
window.exportAllCatalogs = exportAllCatalogs;
window.generateItemsCatalog = generateItemsCatalog;
window.generateBreakablesCatalog = generateBreakablesCatalog;  // NOVO
window.generateRecipesCatalog = generateRecipesCatalog;
window.generateWorkstationsCatalog = generateWorkstationsCatalog;
window.generateMakeshiftConfig = generateMakeshiftConfig;