// Verse Parser - Extracts data from .verse files back into JSON format
// Parses native Verse code generated by export.js (bracket syntax)

const VerseParser = {
    
    // Main parse function - detects catalog type and routes to correct parser
    parse(verseCode, filename) {
        console.log(`ðŸ“– Parsing Verse file: ${filename}`);
        
        if (filename.toLowerCase().includes('items') || verseCode.includes('ItemsCatalog')) {
            return this.parseItemsCatalog(verseCode);
        } else if (filename.toLowerCase().includes('recipes') || verseCode.includes('RecipesCatalog')) {
            return this.parseRecipesCatalog(verseCode);
        } else if (filename.toLowerCase().includes('workstation') || verseCode.includes('WorkstationsCatalog')) {
            return this.parseWorkstationsCatalog(verseCode);
        } else if (filename.toLowerCase().includes('makeshift') || verseCode.includes('MakeshiftConfig')) {
            return this.parseMakeshiftConfig(verseCode);
        } else if (filename.toLowerCase().includes('breakable') || verseCode.includes('BreakableResourcesCatalog') || verseCode.includes('BreakablesCatalog')) {
            return this.parseBreakablesCatalog(verseCode);
        } else {
            throw new Error('Unable to detect catalog type from file');
        }
    },

    // Parse Items Catalog
    parseItemsCatalog(verseCode) {
        const items = [];
        
        // Find the array definition: AllItems<public> : []item_def = array{
        const arrayMatch = verseCode.match(/AllItems<public>\s*:\s*\[\]item_def\s*=\s*array\s*\{([\s\S]*)\}/m);
        if (!arrayMatch) {
            throw new Error('Could not find AllItems array in Verse file');
        }

        const arrayContent = arrayMatch[1];
        
        // Split by item definitions (equipment_def, resource_def, consumable_def, placeable_def)
        const itemBlocks = this.splitByDefinitions(arrayContent, ['equipment_def', 'resource_def', 'consumable_def', 'placeable_def']);
        
        itemBlocks.forEach(block => {
            const item = this.parseItemBlock(block);
            if (item) items.push(item);
        });

        console.log(`âœ“ Parsed ${items.length} items`);
        return items;
    },

    // Split content by definition keywords with bracket syntax
    splitByDefinitions(content, defTypes) {
        const blocks = [];
        let currentBlock = '';
        let braceCount = 0;
        let inBlock = false;
        
        const lines = content.split('\n');
        
        for (let line of lines) {
            const trimmed = line.trim();
            
            // Check if line starts a new definition
            const startsNewDef = defTypes.some(type => trimmed.startsWith(type));
            
            if (startsNewDef && braceCount === 0 && inBlock) {
                // Save previous block
                if (currentBlock.trim()) {
                    blocks.push(currentBlock);
                }
                currentBlock = line + '\n';
                inBlock = true;
                braceCount = (line.match(/\{/g) || []).length - (line.match(/\}/g) || []).length;
            } else if (startsNewDef && !inBlock) {
                // Start first block
                currentBlock = line + '\n';
                inBlock = true;
                braceCount = (line.match(/\{/g) || []).length - (line.match(/\}/g) || []).length;
            } else if (inBlock) {
                currentBlock += line + '\n';
                braceCount += (line.match(/\{/g) || []).length - (line.match(/\}/g) || []).length;
                
                // Block completed when braces balance
                if (braceCount === 0) {
                    blocks.push(currentBlock);
                    currentBlock = '';
                    inBlock = false;
                }
            }
        }
        
        // Add last block if exists
        if (currentBlock.trim()) {
            blocks.push(currentBlock);
        }
        
        return blocks;
    },

    // Parse individual item block
    parseItemBlock(block) {
        const item = {};
        
        // Determine item type
        if (block.includes('equipment_def')) {
            item.type = 'Equipment';
        } else if (block.includes('resource_def')) {
            item.type = 'Resource';
        } else if (block.includes('consumable_def')) {
            item.type = 'Consumable';
        } else if (block.includes('placeable_def')) {
            item.type = 'Placeable';
        } else {
            return null;
        }

        // Extract fields
        item.id = this.extractStringField(block, 'Id');
        item.name = this.extractStringField(block, 'Name');
        item.description = this.extractStringField(block, 'Description');
        item.max_stack = this.extractIntField(block, 'MaxStack');
        item.metadata = this.extractMetadata(block);

        // Type-specific fields
        if (item.type === 'Equipment') {
            item.equip_slot = this.extractEnumField(block, 'EquipSlot');
            item.is_unbreakable = this.extractBoolField(block, 'IsUnbreakable') ? 'true' : 'false';
            item.required_level_to_craft = this.extractIntField(block, 'RequiredLevelToCraft');
            item.exp_after_craft = this.extractIntField(block, 'ExpAfterCraft');
            item.base_stat = this.extractFloatField(block, 'BaseStat');
        } else if (item.type === 'Consumable') {
            item.effect_type = this.extractEnumField(block, 'EffectType');
            item.effect_amount = this.extractFloatField(block, 'Amount');
            item.effect_duration = this.extractFloatField(block, 'Duration');
        } else if (item.type === 'Placeable') {
            item.behavior_type = this.extractEnumField(block, 'PlaceableBehaviorType');
        }

        return item;
    },

    // Parse Recipes Catalog
    parseRecipesCatalog(verseCode) {
        const recipes = [];
        
        const arrayMatch = verseCode.match(/AllRecipes<public>\s*:\s*\[\]recipe_def\s*=\s*array\s*\{([\s\S]*)\}/m);
        if (!arrayMatch) {
            throw new Error('Could not find AllRecipes array in Verse file');
        }

        const arrayContent = arrayMatch[1];
        const recipeBlocks = this.splitByDefinitions(arrayContent, ['recipe_def']);
        
        recipeBlocks.forEach(block => {
            const recipe = this.parseRecipeBlock(block);
            if (recipe) recipes.push(recipe);
        });

        console.log(`âœ“ Parsed ${recipes.length} recipes`);
        return recipes;
    },

    parseRecipeBlock(block) {
        const recipe = {};
        
        recipe.id = this.extractStringField(block, 'Id');
        recipe.output_item_id = this.extractStringField(block, 'OutputItemDefId');
        recipe.output_amount = this.extractIntField(block, 'OutputAmount');
        recipe.skilled_difficulty = this.extractIntField(block, 'SkilledDifficulty');
        recipe.should_start_visible = this.extractBoolField(block, 'ShouldStartVisible');
        recipe.materials = this.extractMaterialsArray(block, 'MaterialRequirements');

        return recipe;
    },

    // Parse Workstations Catalog
    parseWorkstationsCatalog(verseCode) {
        const workstations = [];
        
        const arrayMatch = verseCode.match(/AllWorkstations<public>\s*:\s*\[\]workstation_content_def\s*=\s*array\s*\{([\s\S]*)\}/m);
        if (!arrayMatch) {
            throw new Error('Could not find AllWorkstations array in Verse file');
        }

        const arrayContent = arrayMatch[1];
        const wsBlocks = this.splitByDefinitions(arrayContent, ['workstation_content_def']);
        
        wsBlocks.forEach(block => {
            const ws = this.parseWorkstationBlock(block);
            if (ws) workstations.push(ws);
        });

        console.log(`âœ“ Parsed ${workstations.length} workstations`);
        return workstations;
    },

    parseWorkstationBlock(block) {
        const ws = {};
        
        ws.workstation_def_id = this.extractStringField(block, 'WorkstationDefId');
        ws.available_recipes = this.extractStringArray(block, 'AvailableRecipesIDs');
        ws.upgrades = this.extractUpgrades(block);

        return ws;
    },

    parseBreakablesCatalog(verseCode) {
        const breakables = [];
        const arrayMatch = verseCode.match(/AllBreakables<public>\s*:\s*\[\]breakable_resource_def\s*=\s*array\s*\{([\s\S]*?)\}\s*\n?/m);
        if (!arrayMatch) {
            throw new Error('Could not find AllBreakables array in Verse file');
        }
        const arrayContent = arrayMatch[1];
        let idx = 0;
        while (idx < arrayContent.length) {
            const start = arrayContent.indexOf('breakable_resource_def{', idx);
            if (start === -1) break;
            let braceCount = 0;
            let end = start;
            let foundStart = false;
            for (; end < arrayContent.length; end++) {
                if (arrayContent[end] === '{') {
                    braceCount++;
                    foundStart = true;
                }
                if (arrayContent[end] === '}') {
                    braceCount--;
                    if (foundStart && braceCount === 0) {
                        break;
                    }
                }
            }
            if (start !== -1 && end !== -1 && foundStart) {
                const block = arrayContent.slice(start, end + 1);
                const br = this.parseBreakableBlock(block);
                if (br) breakables.push(br);
                idx = end + 1;
            } else {
                break; // No more blocks found
            }
        }
        console.log(`âœ“ Parsed ${breakables.length} breakables (brace count robust)`);
        return breakables;
    },

    parseBreakableBlock(block) {
        const br = {};
        br.id = this.extractStringField(block, 'Id');
        br.hardness = this.extractFloatField(block, 'Hardness');
        br.regen_seconds = this.extractFloatField(block, 'RegenSeconds');
        br.drop_table = this.extractDropTable(block);
        return br;
    },

    // Helper to extract DropTable -> array of drop entries
    extractDropTable(block) {
        const drops = [];
        const regex = /DropTable\s*:=\s*array\s*\{([\s\S]*?)\}/i;
        const match = block.match(regex);
        if (!match) return drops;

        const arrayContent = match[1];
        // Split into drop_entry blocks
        const dropBlocks = this.splitByDefinitions(arrayContent, ['drop_entry']);
        dropBlocks.forEach(db => {
            const item_id = this.extractStringField(db, 'ItemID') || this.extractStringField(db, 'ItemId') || this.extractStringField(db, 'Item');
            const weight = this.extractIntField(db, 'Weight');
            const min_amount = this.extractIntField(db, 'MinAmount');
            const max_amount = this.extractIntField(db, 'MaxAmount');

            if (item_id) {
                drops.push({
                    item_id,
                    weight,
                    min_amount,
                    max_amount
                });
            }
        });

        return drops;
    },

    // Parse Makeshift Config
    parseMakeshiftConfig(verseCode) {
        const arrayMatch = verseCode.match(/MakeshiftRecipes<public>\s*:\s*\[\]string\s*=\s*array\s*\{([\s\S]*?)\}/m);
        if (!arrayMatch) {
            throw new Error('Could not find MakeshiftRecipes array in Verse file');
        }

        const arrayContent = arrayMatch[1];
        const recipes = this.extractStringArrayFromContent(arrayContent);

        console.log(`âœ“ Parsed ${recipes.length} makeshift recipes`);
        return { available_recipes: recipes };
    },

    // Helper: Extract string field
    extractStringField(block, fieldName) {
        const regex = new RegExp(`${fieldName}\\s*:=\\s*\"([^"]*)\"`, 'i');
        const match = block.match(regex);
        return match ? this.unescapeString(match[1]) : '';
    },

    // Helper: Extract int field
    extractIntField(block, fieldName) {
        const regex = new RegExp(`${fieldName}\\s*:=\\s*(\\d+)`, 'i');
        const match = block.match(regex);
        return match ? parseInt(match[1]) : 0;
    },

    // Helper: Extract float field
    extractFloatField(block, fieldName) {
        const regex = new RegExp(`${fieldName}\\s*:=\\s*([\\d.]+)`, 'i');
        const match = block.match(regex);
        return match ? parseFloat(match[1]) : 0;
    },

    // Helper: Extract bool field
    extractBoolField(block, fieldName) {
        const regex = new RegExp(`${fieldName}\\s*:=\\s*(true|false)`, 'i');
        const match = block.match(regex);
        return match ? match[1] === 'true' : false;
    },

    // Helper: Extract enum field (gets the value after the dot)
    extractEnumField(block, fieldName) {
        const regex = new RegExp(`${fieldName}\\s*:=\\s*\\w+\\.(\\w+)`, 'i');
        const match = block.match(regex);
        return match ? match[1] : '';
    },

    // Helper: Extract metadata map with bracket syntax
    extractMetadata(block) {
        const metadata = {};
        const metadataMatch = block.match(/Metadata\s*:=\s*map\s*\{([^}]*)\}/);
        
        if (!metadataMatch) return metadata;

        const metadataContent = metadataMatch[1];
        const entries = metadataContent.match(/"([^"]+)"\s*=>\s*"([^"]*)"/g);
        
        if (entries) {
            entries.forEach(entry => {
                const match = entry.match(/"([^"]+)"\s*=>\s*"([^"]*)"/);
                if (match) {
                    metadata[this.unescapeString(match[1])] = this.unescapeString(match[2]);
                }
            });
        }

        return metadata;
    },

    // Helper: Extract materials array with bracket syntax
    extractMaterialsArray(block, fieldName) {
        const materials = [];
        const regex = new RegExp(`${fieldName}\\s*:=\\s*array\\s*\\{([\\s\\S]*?)\\}`, 'i');
        const match = block.match(regex);
        
        if (!match) return materials;

        const arrayContent = match[1];
        const materialBlocks = this.splitByDefinitions(arrayContent, ['material_requirement']);

        materialBlocks.forEach(matBlock => {
            const material = {
                item_id: this.extractStringField(matBlock, 'MaterialDefId'),
                amount: this.extractIntField(matBlock, 'Amount')
            };
            if (material.item_id) materials.push(material);
        });

        return materials;
    },

    // Helper: Extract string array with bracket syntax
    extractStringArray(block, fieldName) {
        const array = [];
        const regex = new RegExp(`${fieldName}\\s*:=\\s*array\\s*\\{([\\s\\S]*?)\\}`, 'i');
        const match = block.match(regex);
        
        if (!match) return array;

        const arrayContent = match[1];
        return this.extractStringArrayFromContent(arrayContent);
    },

    extractStringArrayFromContent(content) {
        const array = [];
        const strings = content.match(/"([^"]*)"/g);
        
        if (strings) {
            strings.forEach(str => {
                const cleaned = str.replace(/"/g, '');
                if (cleaned) array.push(this.unescapeString(cleaned));
            });
        }

        return array;
    },

    // Helper: Extract upgrades with bracket syntax
    extractUpgrades(block) {
        const upgrades = [];
        const regex = /UpgradeDefinitions\s*:=\s*array\s*\{([\s\S]*)\}/i;
        const match = block.match(regex);
        
        if (!match) return upgrades;

        const upgradesContent = match[1];
        const upgradeBlocks = this.splitByDefinitions(upgradesContent, ['workstation_upgrade_def']);

        upgradeBlocks.forEach(upBlock => {
            const upgrade = {
                id: this.extractStringField(upBlock, 'Id'),
                target_level: this.extractIntField(upBlock, 'TargetLevel'),
                effect_description: this.extractStringField(upBlock, 'EffectDescription'),
                upgrade_requirements: this.extractMaterialsArray(upBlock, 'UpgradeRequirements'),
                boost_types: this.extractBoostTypes(upBlock),
                available_recipes_ids: this.extractStringArray(upBlock, 'AvailableRecipesIDs')  // NOVO
            };
            if (upgrade.id) upgrades.push(upgrade);
        });

        return upgrades;
    },

    // Helper: Extract boost types array
    extractBoostTypes(block) {
        const boosts = [];
        const regex = /BoostTypes\s*:=\s*array\s*\{([^}]*)\}/i;
        const match = block.match(regex);
        
        if (!match) return boosts;

        const boostsContent = match[1];
        const boostMatches = boostsContent.match(/workstation_boost_type\.(\w+)/g);
        
        if (boostMatches) {
            boostMatches.forEach(match => {
                const boost = match.replace('workstation_boost_type.', '');
                if (boost) boosts.push(boost);
            });
        }

        return boosts;
    },

    // Helper: Unescape Verse strings
    unescapeString(str) {
        return str
            .replace(/\\n/g, '\n')
            .replace(/\\r/g, '\r')
            .replace(/\\t/g, '\t')
            .replace(/\\"/g, '"')
            .replace(/\\\\/g, '\\');
    }
};

// Export to window
window.VerseParser = VerseParser;